package away3d.loaders.parsers{	import away3d.animators.data.SkeletonAnimationSequence;	import away3d.animators.skeleton.JointPose;	import away3d.animators.skeleton.Skeleton;	import away3d.animators.skeleton.SkeletonJoint;	import away3d.animators.skeleton.SkeletonPose;	import away3d.arcane;	import away3d.core.base.SkinnedSubGeometry;	import away3d.core.base.SubGeometry;	import away3d.core.base.SubMesh;	import away3d.core.math.Quaternion;	import away3d.entities.Mesh;	import away3d.events.AssetEvent;	import away3d.events.LoaderEvent;	import away3d.events.ParserEvent;	import away3d.library.AssetLibrary;	import away3d.library.assets.BitmapDataAsset;	import away3d.library.assets.IAsset;	import away3d.loaders.misc.ResourceDependency;	import away3d.materials.BitmapMaterial;	import away3d.materials.ColorMaterial;	import away3d.materials.DefaultMaterialBase;	import away3d.materials.SegmentMaterial;	import away3d.tools.serialize.Serialize;	import away3d.tools.serialize.TraceSerializer;		import flash.display.BitmapData;	import flash.events.Event;	import flash.geom.Matrix3D;	import flash.geom.Vector3D;	import flash.net.URLRequest;	import flash.utils.Dictionary;		import mx.core.BitmapAsset;		import org.ascollada.core.DaeAnimation;	import org.ascollada.core.DaeBlendWeight;	import org.ascollada.core.DaeChannel;	import org.ascollada.core.DaeController;	import org.ascollada.core.DaeDocument;	import org.ascollada.core.DaeGeometry;	import org.ascollada.core.DaeImage;	import org.ascollada.core.DaeInput;	import org.ascollada.core.DaeInstanceController;	import org.ascollada.core.DaeInstanceGeometry;	import org.ascollada.core.DaeNode;	import org.ascollada.core.DaePrimitive;	import org.ascollada.core.DaeSkin;	import org.ascollada.core.DaeSource;	import org.ascollada.core.DaeTransform;	import org.ascollada.fx.DaeBindVertexInput;	import org.ascollada.fx.DaeColor;	import org.ascollada.fx.DaeEffect;	import org.ascollada.fx.DaeInstanceMaterial;	import org.ascollada.fx.DaeLambert;	import org.ascollada.fx.DaeMaterial;	import org.ascollada.fx.DaePhong;
		use namespace arcane;		/**	 * AWDParser provides a parser for the Collada (DAE) data type.	 */	public class ColladaParser extends ParserBase	{		private var _uri : String; // temp, I hope		private var _assetNameToAssign : String; // temp, I hope		private var _daeDoc : DaeDocument;		private var _skeleton : Skeleton;		private var _textureFilenameOverride : String; // TODO, generalize and allow for more than one override				private var _daeParsingState : uint;		private var _bitmapDataAssetMaterialInfo : Object; // daeMaterial.id -> daeLambert		private var _materialIDToSubmesh : Dictionary = new Dictionary(); // daeMaterial.id -> SubMesh		private var _texCoordSets : Object; // adhoc dict - daeMaterial.id -> daeLambert.diffuse.texture.texcoord		private var _overrideBitmapMaterials : Boolean;				/**		 * Creates a new ColladaParser object.		 * @param uri The url or id of the data or file to be parsed. TODO: to be removed, and errors sent as events to AssetLoader, where uri is available.		 * @param skeleton Skeleton object if animations are being parsed (REQUIRED if skeleton not in same file as animation)		 * @param textureFilenameOverride a single texture to be loaded instead of referenced texture in file. TODO: fix to allow multiple overrides		 */		public function ColladaParser(uri : String, assetNameToAssign : String = null, skeleton : Skeleton = null, textureFilenameOverride : String = null)		{			// TODO, remove uri			// TODO, remove textureFilenameOverride - instead, turn off loading of dependencies and figure out how to associate application provided texture with materialID 			_uri = uri;			if (assetNameToAssign != null)			{				_assetNameToAssign = assetNameToAssign;			}			else			{				_assetNameToAssign = "";			}						if (skeleton)			{				_skeleton = skeleton;			}			else			{				_skeleton = new Skeleton();			}			_textureFilenameOverride = textureFilenameOverride;			_bitmapDataAssetMaterialInfo = new Object();			_texCoordSets = new Object();			super(ParserDataFormat.PLAIN_TEXT);		}				/**		 * @inheritDoc		 */		public static function supportsType(extension : String) : Boolean		{			extension = extension.toLowerCase();			return extension == "dae";		}				/**		 * @inheritDoc		 */		override arcane function resolveDependency(resourceDependency:ResourceDependency):void		{			var daeMaterialID:String = resourceDependency.id;			if (_bitmapDataAssetMaterialInfo.hasOwnProperty(daeMaterialID))			{				var daeLambert:DaeLambert = _bitmapDataAssetMaterialInfo[daeMaterialID];								// there should be one bitmapAsset returned for each resourceDependency.				// we'll get separate callbacks for each materialID.				var bitmapDataAsset:BitmapDataAsset = resourceDependency.assets[0] as BitmapDataAsset;				if (bitmapDataAsset != null && (bitmapDataAsset.bitmapData != null) && isBitmapDataValid(bitmapDataAsset.bitmapData))				{					trace("-- [", filenameFromPath(),"] Loaded bitmap for", daeMaterialID);						createAndCacheBitmapMaterial(daeMaterialID, bitmapDataAsset.bitmapData, daeLambert);				}				else				{					createAndCacheColorMaterial(daeMaterialID, 0xFF0000, daeLambert);				}								delete _bitmapDataAssetMaterialInfo[daeMaterialID];			}		}				/**		 * @inheritDoc		 */		override arcane function resolveDependencyFailure(resourceDependency:ResourceDependency):void		{			// apply system default			var daeMaterialID:String = resourceDependency.id;			if (_bitmapDataAssetMaterialInfo.hasOwnProperty(daeMaterialID))			{				var daeLambert:DaeLambert = _bitmapDataAssetMaterialInfo[daeMaterialID];								createAndCacheColorMaterial(daeMaterialID, 0xFF0000, daeLambert);								delete _bitmapDataAssetMaterialInfo[daeMaterialID];			}		}				/**		 * Tests whether a data block can be parsed by the parser.		 * @param data The data block to potentially be parsed.		 * @return Whether or not the given data is supported.		 */		public static function supportsData(data : *) : Boolean		{			// todo: implement			return false;		}				private function filenameFromPath():String		{			var lastSlashIndex:int = this._uri.lastIndexOf("/");			if (lastSlashIndex == -1)			{				return this._uri;			}			else			{				return this._uri.slice(lastSlashIndex+1);			}		}				/**		 * @inheritDoc		 */		protected override function proceedParsing() : Boolean		{			// _daeParsingState key			// 0:just starting			// 1:parsing dae			// 2:done parsing dae, images requested			// 3:completely done			// ... : materials assigned one dependencies loaded.						if (_daeParsingState == 0)			{				// set this to true to override every specified texture with red material instead				_overrideBitmapMaterials = false;								trace("-- [", filenameFromPath(),"] [1] collada parse requested");				_daeDoc = new DaeDocument();				var xml:XML = new XML(_textData);				_daeDoc.addEventListener(Event.COMPLETE, onParseColladaDocComplete);				_daeDoc.read(xml);								// right order to do things (based on DAE.as from Papervision3D)				// 1. load all "referred to" dae files, if any.  I'll skip this step to start with - hopefully will not need it.				// 2. iterate through DaeMaterial's.  I assume this loads textures and caches references.				// 3. iterate through DaeNode's (recursive). (this brings in geometry and skins)				// 4. iterate through DaeAnimation's (NOT WORKING)								_daeParsingState++; // to 1								return MORE_TO_PARSE;			}			else if (_daeParsingState == 1)			{				// collada parse in process				return MORE_TO_PARSE;			}			else if (_daeParsingState == 2)			{				continueColladaInterpret();				return MORE_TO_PARSE;			}			else			{				trace("-- [", filenameFromPath(),"] [3] parsing done!");				return PARSING_DONE;			}		}				private function notifyGoingToStage3():void		{			trace("-- [", filenameFromPath(),"] [3] image loads completed (if any).");		}				// The doc has been read in. Now it must be processed.		private function onParseColladaDocComplete(e:Event):void		{			var requestedBitmaps : Boolean;			// begin interpret _daeDoc						// 2. iterate through DaeMaterial's			for each (var daeMaterial:DaeMaterial in _daeDoc.materials)			{				var daeEffect:DaeEffect = _daeDoc.effects[daeMaterial.instance_effect];								if (daeEffect != null)				{					if (daeEffect.shader is DaeLambert)					{						var daeLambert:DaeLambert = daeEffect.shader as DaeLambert;												if (daeLambert.diffuse.texture && daeEffect.surface)						{							if (_overrideBitmapMaterials)							{								createAndCacheColorMaterial(daeMaterial.id, 0xFF0000, daeLambert);							}							else							{								// save texCoord reference for later usage 								_texCoordSets[daeMaterial.id] = daeLambert.diffuse.texture.texcoord;																// figure out which texture to load								var daeImage:DaeImage = _daeDoc.images[daeEffect.surface.init_from];								if (daeImage)								{									var imageURI:String;																		// look for texture override									if (_textureFilenameOverride)									{										imageURI = _textureFilenameOverride;									}									else									{										// TODO: the slice is too special-case										var aPath : Array = _uri.split("/");										aPath.pop();										imageURI = aPath.join("/") + "/" + daeImage.init_from.slice(2, daeImage.init_from.length);									}									// request bitmap resource that is referenced herein									trace("-- [", filenameFromPath(),"] Requesting bitmap", imageURI);									_dependencies.push(new ResourceDependency(daeMaterial.id, new URLRequest(imageURI), null, this));									registerBitmapMaterialWaitingForBitmapData(daeMaterial.id, daeLambert);									requestedBitmaps = true;								}							}						}						else if (daeLambert.diffuse.color)						{							if (daeEffect.wireframe)							{								createAndCacheWireframeMaterial(daeMaterial.id, buildColor(daeLambert.diffuse.color), daeLambert);							}							else							{								createAndCacheColorMaterial(daeMaterial.id, buildColor(daeLambert.diffuse.color), daeLambert);							}						}					}				}			}			trace("-- [", filenameFromPath(),"] [2] collada parse completed. image loads requested (if any).");			_daeParsingState++; // to 2		}				private function registerBitmapMaterialWaitingForBitmapData(daeMaterialID:String, daeLambert:DaeLambert):void		{			// many materials may request the same bitmap. this allows them to be loaded			if (!_bitmapDataAssetMaterialInfo.hasOwnProperty(daeMaterialID))			{				_bitmapDataAssetMaterialInfo[daeMaterialID] = daeLambert;			}			else			{				trace("-- [", filenameFromPath(),"] material id", daeMaterialID, "already requested?!?!?!?!");			}		}				private function createAndCacheColorMaterial(daeMaterialID:String, color:uint, daeLambert:DaeLambert):void		{			if (_materialIDToSubmesh.hasOwnProperty(daeMaterialID))			{				var subMesh:SubMesh = _materialIDToSubmesh[daeMaterialID];				var material:ColorMaterial = new ColorMaterial(color);				material.name = daeMaterialID;				material.gloss = 20;				material.specular = 1.5;				material.ambientColor = 0x505060;				applyMaterialParams(material, daeLambert);				subMesh.material = material;				//finalizeAsset(material);			}		}				private function createAndCacheBitmapMaterial(daeMaterialID:String, bitmapData:BitmapData, daeLambert:DaeLambert):void		{			if (_materialIDToSubmesh.hasOwnProperty(daeMaterialID))			{				var subMesh:SubMesh = _materialIDToSubmesh[daeMaterialID];				var material:BitmapMaterial = new BitmapMaterial(bitmapData);				material.name = daeMaterialID;				applyMaterialParams(material, daeLambert);				subMesh.material = material;				//finalizeAsset(material);			}		}				private function createAndCacheWireframeMaterial(daeMaterialID:String, color:uint, daeLambert:DaeLambert):void		{			if (_materialIDToSubmesh.hasOwnProperty(daeMaterialID))			{				var subMesh:SubMesh = _materialIDToSubmesh[daeMaterialID];				var material:SegmentMaterial = new SegmentMaterial(); // TODO: figure out how to apply lambert.diffuse.color to the wireframe material				material.name = daeMaterialID;				subMesh.material = material;				//finalizeAsset(material);			}		}		private function continueColladaInterpret():void		{			// 3. iterate through DaeNode's			if (_daeDoc.scene != null)			{				for each (var daeNode:DaeNode in _daeDoc.scene.nodes)				{					if (daeNode.type == "JOINT")					{						var skeletonDefaultPose:SkeletonPose = new SkeletonPose();						skeletonAndDefaultPoseFromNode(_skeleton, skeletonDefaultPose, daeNode, -1);						_skeleton.name = _daeDoc.scene.id;						finalizeAsset(_skeleton);						skeletonDefaultPose.name = _skeleton.name+"_default";						finalizeAsset(skeletonDefaultPose);					}					else					{						meshFromNode(null /* parent */, daeNode, new Matrix3D());					}				}			}						// 4. iterate through DaeAnimation's			if (_daeDoc.animations != null)			{				var skeletonPoses:Dictionary;								for each (var daeAnimation:DaeAnimation in _daeDoc.animations)				{					if (skeletonPoses == null)					{						skeletonPoses = new Dictionary();											}					skeletonPosesFromAnimation(skeletonPoses, daeAnimation);				}								if (skeletonPoses != null)				{					// sort poses based on keyFrameTime (the key in the skeletonPoses Dictionary)					var keyFrameTimes:Vector.<String> = new Vector.<String>;					var keyFrameTime:String;					for (keyFrameTime in skeletonPoses)					{						keyFrameTimes.push(keyFrameTime);					}										// temp use URI to identify animation sequence					var skeletonAnimationSequence:SkeletonAnimationSequence = new SkeletonAnimationSequence("anim"); 					var sortedKeyFrameTimes:Vector.<String> = keyFrameTimes.sort(sortStringsAsNumbers);					var duration:Number = Number(sortedKeyFrameTimes[1])- Number(sortedKeyFrameTimes[0]);					for each (keyFrameTime in sortedKeyFrameTimes)					{						var skeletonPose:SkeletonPose = new SkeletonPose();						var jointPoses:Dictionary = skeletonPoses[keyFrameTime];						for (var jointName:String in jointPoses)						{							// find out which jointIndex this skeleton has for this jointName							var jointIndex:int = _skeleton.jointIndexFromName(jointName);							if (jointIndex != -1)							{								var jointPose:JointPose = jointPoses[jointName];								ensureEnoughJointPoses(skeletonPose.jointPoses, jointIndex);								skeletonPose.jointPoses[jointIndex] = jointPose;							}							else							{								var parseErrorEvent:ParserEvent = new ParserEvent(ParserEvent.PARSE_ERROR);								dispatchEvent(parseErrorEvent);								// TODO, send more specific information in parseErrorEvent.								trace("-- [", filenameFromPath(),"] ERROR: jointName", jointName, "not in provided skeleton!");							}						}												skeletonAnimationSequence.addFrame(skeletonPose, duration);					}										//var traceSerializer:TraceSerializer = new TraceSerializer();					//Serialize.serializeSkeletonAnimationSequence(skeletonAnimationSequence, traceSerializer);					finalizeAsset(skeletonAnimationSequence);				}			}			_daeParsingState++; // to 3		}				private function ensureEnoughJointPoses(jointPoses:Vector.<JointPose>, numJointsNeeded:uint):void		{			var numJoints:uint = jointPoses.length;						while (numJoints < numJointsNeeded)			{				jointPoses.push(new JointPose());				numJoints++;			}		}				private function sortStringsAsNumbers(a:String, b:String):Number		{			if (Number(a) < Number(b))			{				return -1;			}			else if (Number(a) > Number(b))			{				return 1;			}			else			{				return 0;			}		}				private function applyMaterialParams(material:DefaultMaterialBase, daeLambert:DaeLambert):void		{			//daeLambert.emission			//daeLambert.transparent			//daeLambert.transparency						if (daeLambert.ambient.color)			{				material.ambientColor = buildColor(daeLambert.ambient.color);			}						if (daeLambert.diffuse.color)			{				material.diffuseMethod.diffuseColor = buildColor(daeLambert.diffuse.color);			}						if (daeLambert is DaePhong)			{				var daePhong:DaePhong = daeLambert as DaePhong;								if (daePhong.specular.color)				{					material.specularColor = buildColor(daePhong.specular.color);				}								//daePhong.shininess				//daePhong.reflective				//daePhong.reflectivity			}		}				private function matrixFromTransform(matrix:Matrix3D, daeTransform:DaeTransform):void		{			var v:Vector.<Number> = daeTransform.data;			switch (daeTransform.nodeName)			{				case "rotate":					matrix.appendRotation(v[3], new Vector3D(v[0], v[1], v[2]));					break;				case "scale":					matrix.appendScale(v[0], v[1], v[2]);					break;				case "translate":					matrix.appendTranslation(v[0], v[1], v[2]);					break;				case "matrix":					matrix.append(matrix3DFromColladaData(v));					break;				// missing at least				// "lookat"				// "skew"				default:					throw new Error("Unknown transform type: " + daeTransform.nodeName);			}		}				private function matrixFromNode(matrix:Matrix3D, daeNode:DaeNode):void		{			// setup the initial transform - there may be several that collada stacks together here.			for each (var daeTransform:DaeTransform in daeNode.transforms)			{				matrixFromTransform(matrix, daeTransform);			}		}				private function skeletonAndDefaultPoseFromNode(skeleton:Skeleton, skeletonDefaultPose:SkeletonPose, daeNode:DaeNode, parentJointIndex:int):void		{			var thisSkeletonJoint:SkeletonJoint = new SkeletonJoint();			thisSkeletonJoint.parentIndex = parentJointIndex;			thisSkeletonJoint.name = daeNode.name;			var jointIndex:int = skeleton.joints.push(thisSkeletonJoint);						var nodeTransform:Matrix3D = new Matrix3D();			matrixFromNode(nodeTransform, daeNode);						var orientation:Quaternion = new Quaternion();			orientation.fromMatrix(nodeTransform);			var translation:Vector3D = nodeTransform.position;						var thisJointPose:JointPose = new JointPose();			thisJointPose.name = daeNode.name;			skeletonDefaultPose.jointPoses.push(thisJointPose);			thisJointPose.orientation = orientation;			thisJointPose.translation = translation;						// recurse node children			for each (var daeChildNode:DaeNode in daeNode.nodes)			{				skeletonAndDefaultPoseFromNode(skeleton, skeletonDefaultPose, daeChildNode, jointIndex);			}		}				private function skeletonPosesFromAnimation(skeletonPoses:Dictionary, daeAnimation:DaeAnimation):void		{			for each (var daeChannel:DaeChannel in daeAnimation.channels)			{				var jointName:String = daeChannel.targetID;				var inputDaeSource:DaeSource = daeChannel.sampler.input; // keyframe time values				var outputDaeSource:DaeSource = daeChannel.sampler.output; // pose matrices				// TODO!				//var interpolationsDaeSource:DaeSource = daeChannel.sampler.interpolations; // interpolation type for animation between poses								// TODO: properly handle/bake together multiple daeChannel - at this point, our data only contains one daeChannel per anim/joint				var inputIndex:uint;				for each (var input:Number in inputDaeSource.dataFloat)				{					// retrieve or create Vector.<JointPose> for this input (time)					// we do this instead of SkeletonPose (at this time) because 					// there may be more than one daeChannel affecting the same joints.					var inputString:String = String(input);					//var jointPoses:Vector.<JointPose>;					var jointPoses:Dictionary;					if (skeletonPoses.hasOwnProperty(inputString))					{						jointPoses = skeletonPoses[inputString];					}					else					{						//jointPoses = new Vector.<JointPose>();						jointPoses = new Dictionary();						skeletonPoses[inputString] = jointPoses;					}										var jointPose:JointPose = new JointPose();					jointPose.name = jointName;										var poseTransform:Matrix3D;					if (outputDaeSource.accessor.params[0].type == "float")					{						// HACK, possibly not right.  If float array shows up here, I guess these might be always 1's, and that that means "identity".  Dunno.						poseTransform = new Matrix3D();											}					else					{						// get matrix from outputDaeSource						poseTransform = matrix3DFromColladaData(outputDaeSource.dataFloat[inputIndex]);					}										jointPose.translation = poseTransform.position;					var orientation:Quaternion = new Quaternion();					orientation.fromMatrix(poseTransform);					jointPose.orientation = orientation;										//jointPoses.push(jointPose);					if (jointPoses.hasOwnProperty(jointPose.name))					{						var parseErrorEvent:ParserEvent = new ParserEvent(ParserEvent.PARSE_ERROR);						dispatchEvent(parseErrorEvent);						// TODO, send more specific information in parseErrorEvent.						trace("-- [", filenameFromPath(),"] ERROR: jointName", jointPose.name, "already exists in pose!");					}					jointPoses[jointPose.name] = jointPose;					inputIndex++;				}			}		}				private function meshFromNode(parent:Mesh, daeNode:DaeNode, accumulatedTransform:Matrix3D, addToParentMesh:Boolean = false):void		{			var daeGeometry:DaeGeometry;			var daeInstanceMaterial:DaeInstanceMaterial;			var daePrimitive:DaePrimitive;			var daeBindVertexInput:DaeBindVertexInput;			var indexIsDupeOf:Vector.<int>;			var instance:Mesh;			if (addToParentMesh)			{				// reuse existing mesh - do not add geometry from this node to a separate mesh.				instance = parent;								var nodeMatrix:Matrix3D = new Matrix3D();				matrixFromNode(nodeMatrix, daeNode);				accumulatedTransform.prepend(nodeMatrix);			}			else			{				instance = new Mesh();							if (parent != null)				{					parent.addChild(instance);				}								matrixFromNode(instance.transform, daeNode);				accumulatedTransform.prepend(instance.transform);								instance.name = daeNode.name;			}						// We make an assumption here - if there is a DaeInstanceController, then there will NOT be a DaeInstanceGeometry.			// Spec isn't clear whether there can be both in a single node.						// We also assume that all nodes in the tree are either ALL skins or not. (addToParentMesh changed to true below)      var childAddToParentMesh:Boolean;			if (daeNode.controllerInstances.length)			{				for each (var daeInstanceController:DaeInstanceController in daeNode.controllerInstances)				{					var daeController:DaeController = daeNode.document.controllers[daeInstanceController.url];										// controllers, can be of type 'skin' or 'morph'					if (daeController.skin)					{            childAddToParentMesh = true;						daeGeometry = daeNode.document.geometries[daeController.skin.source];						for each (daeInstanceMaterial in daeInstanceController.bindMaterial.instanceMaterials)						{							for each (daePrimitive in daeGeometry.mesh.primitives)							{								// pick out the right daePrimitive for this daeInstanceMaterial								if (daeInstanceMaterial.symbol == daePrimitive.material)								{									var skinnedSubGeometry:SkinnedSubGeometry = new SkinnedSubGeometry(daeController.skin.joints.length);									instance.geometry.addSubGeometry(skinnedSubGeometry);																		// DaeInstanceMaterial.target corresponds to DaeMaterial.name									cacheMaterialReference(instance, skinnedSubGeometry as SubGeometry, daeInstanceMaterial.target);									// figure out accumulated Bind Shape Matrix for this skin									var accumulatedBindShapeMatrix:Matrix3D = accumulatedTransform.clone();									accumulatedBindShapeMatrix.prepend(matrix3DFromColladaData(daeController.skin.bind_shape_matrix.data));																		// retrieve correct texcoord-set for the material, and the correct BindVertexInput									// TODO: input_semantic here probably shouldn't be hardcoded.									// TODO: any way to eliminate _texCoordSets[] dictionary?									daeBindVertexInput = daeInstanceMaterial.findBindVertexInput(_texCoordSets[daeInstanceMaterial.target], "TEXCOORD");									if (daeBindVertexInput == null) throw new Error("DaeBindVertexInput null!");									indexIsDupeOf = determineDupes(daePrimitive, daeBindVertexInput.input_set);									applyGeometry(skinnedSubGeometry, daePrimitive, accumulatedBindShapeMatrix, indexIsDupeOf, daeBindVertexInput.input_set, instance);									applyJoints(skinnedSubGeometry, daeController.skin);																		// we found the daePrimitive that corresponds to this daeInstanceMaterial. stop looking.									break;								}							}						}					}					else if (daeController.morph)					{						throw new Error("morph!");					}					else					{						throw new Error("A COLLADA controller should be of type <skin> or <morph>!");					}				}			}			else if (daeNode.geometryInstances.length)			{				for each (var daeInstanceGeometry:DaeInstanceGeometry in daeNode.geometryInstances)				{					daeGeometry = daeNode.document.geometries[daeInstanceGeometry.url];					for each (daeInstanceMaterial in daeInstanceGeometry.bindMaterial.instanceMaterials)					{						for each (daePrimitive in daeGeometry.mesh.primitives)						{							// pick out the right daePrimitive for this daeInstanceMaterial							if (daeInstanceMaterial.symbol == daePrimitive.material)							{								var subGeometry:SubGeometry = new SubGeometry();								instance.geometry.addSubGeometry(subGeometry);																// DaeInstanceMaterial.target corresponds to DaeMaterial.name								cacheMaterialReference(instance, subGeometry, daeInstanceMaterial.target);																// retrieve correct texcoord-set for the material, and the correct BindVertexInput								// TODO: input_semantic here probably shouldn't be hardcoded.								// TODO: any way to eliminate _texCoordSets[] dictionary?								daeBindVertexInput = daeInstanceMaterial.findBindVertexInput(_texCoordSets[daeInstanceMaterial.target], "TEXCOORD");								if (daeBindVertexInput == null) throw new Error("DaeBindVertexInput null!");								indexIsDupeOf = determineDupes(daePrimitive, daeBindVertexInput.input_set);								applyGeometry(subGeometry, daePrimitive, null, indexIsDupeOf, daeBindVertexInput.input_set, instance);																// we found the daePrimitive that corresponds to this daeInstanceMaterial. stop looking.								break;							}						}					}				}			}						// recurse node children			for each (var daeChildNode:DaeNode in daeNode.nodes)			{				meshFromNode(instance /* parent */, daeChildNode, accumulatedTransform, childAddToParentMesh);			}			      if (!addToParentMesh)       {			  finalizeAsset(instance);      }		}				private function determineDupes(daePrimitive:DaePrimitive, uvInputSet:int):Vector.<int>		{			var vertexIndexes:Vector.<Vector.<uint>> = daePrimitive.triangles;			var normalIndexes:Vector.<Vector.<uint>> = daePrimitive.normals;			var uvIndexes:Vector.<Vector.<uint>> = daePrimitive.getUVSet(uvInputSet);						// 3 vertices (indexes, really) per triangle			// hence, numIndexData here will be 3x number of triangles			var numTriangles:uint = daePrimitive.triangles.length;			var numIndexData:uint = numTriangles*3;						// looks for unique combinations of vertIndex, normIndex, uvIndex			// uniques of those 3 items will indicate the minimum number of indexes we need for the subGeometry we're building.			var indexIsDupeOf:Vector.<int> = new Vector.<int>(numIndexData);						var i:uint, j:uint;						for (i = 0; i < numIndexData; i++)			{				// initialize to "not a dupe"				indexIsDupeOf[i] = -1;			}						for (i = 0; i < numIndexData; i++)			{				if (indexIsDupeOf[i] == -1)				{					var tnumi : int = i / 3; // tri num					var vnumi : int = i % 3; // vert num (within tri)					for (j = i + 1; j < numIndexData; j++)					{						var tnumj : int = j / 3; // tri num						var vnumj : int = j % 3; // vert num (within tri)						if ((vertexIndexes[tnumi][vnumi] == vertexIndexes[tnumj][vnumj]) &&							(normalIndexes[tnumi][vnumi] == normalIndexes[tnumj][vnumj]) &&							(uvIndexes[tnumi][vnumi]     == uvIndexes[tnumj][vnumj]))						{							// dupe vertexes are defined as equal vertex,normal,uv indexes.							indexIsDupeOf[j] = i;						}					}				}			}						return indexIsDupeOf;		}				private function cacheMaterialReference(instance:Mesh, subGeometry:SubGeometry, daeMaterialID:String):void		{			// find which SubMesh has this SubGeometry			// TODO: there should be a more convenient way to discover the SubMesh for a given SubGeometry			var subMesh:SubMesh;			for each (subMesh in instance.subMeshes)			{				if (subMesh.subGeometry == subGeometry)				{					break;				}			}						// assign proper material to this subMesh			_materialIDToSubmesh[daeMaterialID] = subMesh;		}					// this will copy mesh data defined in daePrimitive to subGeometry.		// * daePrimitive is the higher level definition of the mesh.		// * daeSkin (possibly null) to indicate bind_shape_matrix		// * indexIsDupeOf is vertex remapping table - indexed via oldVertexIndex, storing newVertexIndex		// * uvInputSet is index into uvSets		// * instance is the mesh to which the subGeometry is attached		private function applyGeometry(subGeometry:SubGeometry, daePrimitive:DaePrimitive, accumulatedBindShapeMatrix:Matrix3D,																	indexIsDupeOf:Vector.<int>, uvInputSet:int, instance:Mesh):void		{						var vertexIndexes:Vector.<Vector.<uint>> = daePrimitive.triangles;			var normalIndexes:Vector.<Vector.<uint>> = daePrimitive.normals;			var uvIndexes:Vector.<Vector.<uint>> = daePrimitive.getUVSet(uvInputSet);						// 3 vertices (indexes, really) per triangle			// hence, numIndexData here will be 3x number of triangles			var numTriangles:uint = daePrimitive.triangles.length;			var numIndexData:uint = numTriangles*3;						var indexData:Vector.<uint> = new Vector.<uint>();			var vertexData:Vector.<Number> = new Vector.<Number>();			var normalData:Vector.<Number> = new Vector.<Number>();			var uvData:Vector.<Number> = new Vector.<Number>();						var newVertexIndex : uint = 0;			var normalSource : DaeSource = daePrimitive.document.sources[daePrimitive.normalInput.source];			var uvInput : DaeInput = daePrimitive.getTexCoordInput(uvInputSet);			var uvSource : DaeSource = daePrimitive.document.sources[uvInput.source];			var accumulatedBindShapeMatrixWithoutTranslate:Matrix3D;			if (accumulatedBindShapeMatrix)			{				accumulatedBindShapeMatrixWithoutTranslate = accumulatedBindShapeMatrix.clone();				accumulatedBindShapeMatrixWithoutTranslate.position.setTo(0,0,0);			}						var i:uint;			for (i = 0; i < numIndexData; i++)			{				if (indexIsDupeOf[i] == -1)				{					var tnum : int = i / 3; // tri num					var vnum : int = i % 3; // vert num (within tri)										indexData.push(newVertexIndex);										// TODO: these transforms (vertex AND normal) might be better done as a group then one at a time.					var oldVertexIndex : uint = vertexIndexes[tnum][vnum];					var vertex:Vector3D = new Vector3D(						daePrimitive.vertices.source.dataFloat[oldVertexIndex][0],						daePrimitive.vertices.source.dataFloat[oldVertexIndex][1],						daePrimitive.vertices.source.dataFloat[oldVertexIndex][2]);					if (accumulatedBindShapeMatrix)					{						vertex = accumulatedBindShapeMatrix.transformVector(vertex);					}					vertexData.push(vertex.x);					vertexData.push(vertex.y);					vertexData.push(vertex.z);										var oldNormalIndex : uint = normalIndexes[tnum][vnum];					var normal:Vector3D = new Vector3D(						normalSource.dataFloat[oldNormalIndex][0],						normalSource.dataFloat[oldNormalIndex][1],						normalSource.dataFloat[oldNormalIndex][2]);					if (accumulatedBindShapeMatrixWithoutTranslate)					{						normal = accumulatedBindShapeMatrixWithoutTranslate.transformVector(normal);					}					normalData.push(normal.x);					normalData.push(normal.y);					normalData.push(normal.z);										var oldUVIndex : uint = uvIndexes[tnum][vnum];					uvData.push(      uvSource.dataFloat[oldUVIndex][0]);					uvData.push(1.0 - uvSource.dataFloat[oldUVIndex][1]); // must flip the v around.										newVertexIndex++;				}				else				{					// indexIsDupeOf[] holds index into indexData, and is LOWEST duplicate vert (including vert,normal,uv).					// indexData[] holds newVertexIndex					indexData.push(indexData[indexIsDupeOf[i]]);				}			}						var parseErrorEvent:ParserEvent;			if ((vertexData.length != normalData.length) ||				((vertexData.length / 3) != (uvData.length / 2)))			{				parseErrorEvent = new ParserEvent(ParserEvent.PARSE_ERROR);				dispatchEvent(parseErrorEvent);				// TODO, send more specific information in parseErrorEvent.				trace("-- [", filenameFromPath(),"] vertexData, normalData, and uvData should have same relative number of elements");				trace("-- [", filenameFromPath(),"]  vertexData", vertexData.length / 3, "normalData", normalData.length / 3, "uvData", uvData.length / 2);			}						for (i = 0; i < indexData.length; i++)			{				if (indexData[i] > (vertexData.length / 3) - 1)				{					parseErrorEvent = new ParserEvent(ParserEvent.PARSE_ERROR);					dispatchEvent(parseErrorEvent);					// TODO, send more specific information in parseErrorEvent.					trace("-- [", filenameFromPath(),"] index value (", indexData[i], ") bigger than largest of vertex/normal/uv index (", (vertexData.length / 3) - 1, ")"); 				}			}						subGeometry.updateIndexData(indexData); // triangle indices (into vertex, normal, and uv data)			subGeometry.updateVertexData(vertexData);			subGeometry.updateVertexNormalData(normalData);			subGeometry.updateUVData(uvData);		}				// Comment from Richard Olsson on away3d team.		// As far as skeletons are concerned, there are a couple of things that I've bumped into and that I have had to work around.		// Most importantly (and least obviously) you need to think of three things concerning weights: 		//  All vertices must have the same number of weights (so pad with zero weights if necessary.)		//  A non-zero weight may never come after a zero weight, because the algorithm stops reading weights for a vertex after the first zero weight.		//  All weights must be normalized so that if a vertex as three weights, the sum of those three weights are one.				// TODO: eventually vertexGroups play a part here		private function applyJoints(skinnedSubGeometry:SkinnedSubGeometry, daeSkin:DaeSkin):void		{			var maxJointsPerVertex : uint = daeSkin.joints.length;			var numIndices : uint = skinnedSubGeometry.numTriangles * 3;			// this seems like it's wrong - should be Vector.<uint> if its really indexes?!?!			var jointIndexData : Vector.<Number>   = new Vector.<Number>(numIndices * maxJointsPerVertex, true);			var jointWeightsData : Vector.<Number> = new Vector.<Number>(numIndices * maxJointsPerVertex, true);						// TODO, what to do with daeSkin.bind_shape_matrix			// matrix3DFromColladaData(daeSkin.bind_shape_matrix.data)			var localJointIndex:uint = 0; // jointIndex just for this file - might be different if many colladas are merged			for each (var jointNames:Vector.<String> in daeSkin.joints)			{				var jointName:String = jointNames[0];				var jointIndex:int = _skeleton.jointIndexFromName(jointName); // we need the index - or else we'd simply call jointFromName()				if (jointIndex != -1)				{					var joint:SkeletonJoint = _skeleton.joints[jointIndex];					var daeBlendWeights:Vector.<DaeBlendWeight> = daeSkin.getBlendWeightsForJoint(jointName); // inside joints vector is always one element long										var invBindMatrix : Matrix3D = new Matrix3D();					matrixFromTransform(invBindMatrix, daeSkin.inv_bind_matrix[localJointIndex]);					joint.inverseBindPose = invBindMatrix.rawData;					for each (var daeBlendWeight:DaeBlendWeight in daeBlendWeights)					{						var indexIntoDatas : uint = (daeBlendWeight.vertexIndex * maxJointsPerVertex) + jointIndex;						// jointIndexes need to be multiplied by 3 (amount of matrix registers)						// NOTE: this came from NSSSkinMesh example code						jointIndexData  [indexIntoDatas] = jointIndex * 3;						jointWeightsData[indexIntoDatas] = daeBlendWeight.weight;					}				}				else				{					var parseErrorEvent:ParserEvent = new ParserEvent(ParserEvent.PARSE_ERROR);					dispatchEvent(parseErrorEvent);					// TODO, send more specific information in parseErrorEvent.					trace("-- [", filenameFromPath(),"] ERROR: jointName", jointName, "not defined in skeleton!");				}								localJointIndex++;			}						skinnedSubGeometry.jointIndexData = jointIndexData;			skinnedSubGeometry.jointWeightsData = jointWeightsData;		}				/**		 * Build a color from RGB values.		 * 		 * @param	rgb		 *  		 * @return		 */		private function buildColor(daeColor:DaeColor):uint		{			var r:uint = daeColor.r * 0xff;			var g:uint = daeColor.g * 0xff;			var b:uint = daeColor.b * 0xff;			return (r<<16|g<<8|b);		}				private function matrix3DFromColladaData(rowMajorDataFromCollada:Vector.<Number>):Matrix3D		{			var result : Matrix3D = new Matrix3D();			var columnMajorData : Vector.<Number> = result.rawData;						// collada data is in row-major order.  Matrix3D expects column-major.  transpose here			columnMajorData[0]  = rowMajorDataFromCollada[0];			columnMajorData[1]  = rowMajorDataFromCollada[4];			columnMajorData[2]  = rowMajorDataFromCollada[8];			columnMajorData[3]  = rowMajorDataFromCollada[12];			columnMajorData[4]  = rowMajorDataFromCollada[1];			columnMajorData[5]  = rowMajorDataFromCollada[5];			columnMajorData[6]  = rowMajorDataFromCollada[9];			columnMajorData[7]  = rowMajorDataFromCollada[13];			columnMajorData[8]  = rowMajorDataFromCollada[2];			columnMajorData[9]  = rowMajorDataFromCollada[6];			columnMajorData[10] = rowMajorDataFromCollada[10];			columnMajorData[11] = rowMajorDataFromCollada[14];			columnMajorData[12] = rowMajorDataFromCollada[3]; // translation x			columnMajorData[13] = rowMajorDataFromCollada[7]; // translation y			columnMajorData[14] = rowMajorDataFromCollada[11]; // translation z			columnMajorData[15] = rowMajorDataFromCollada[15];						return result;		}	}}