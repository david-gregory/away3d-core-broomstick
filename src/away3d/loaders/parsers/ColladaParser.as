package away3d.loaders.parsers{	import away3d.animators.data.SkeletonAnimationSequence;	import away3d.animators.skeleton.JointPose;	import away3d.animators.skeleton.Skeleton;	import away3d.animators.skeleton.SkeletonJoint;	import away3d.animators.skeleton.SkeletonPose;	import away3d.arcane;	import away3d.core.base.SkinnedSubGeometry;	import away3d.core.base.SubGeometry;	import away3d.core.base.SubMesh;	import away3d.core.math.Quaternion;	import away3d.entities.Mesh;	import away3d.events.ParserEvent;	import away3d.library.assets.BitmapDataAsset;	import away3d.loaders.misc.ResourceDependency;	import away3d.materials.BitmapMaterial;	import away3d.materials.ColorMaterial;	import away3d.materials.DefaultMaterialBase;	import away3d.materials.SegmentMaterial;	import away3d.tools.serialize.TraceSerializer;		import flash.display.BitmapData;	import flash.events.Event;	import flash.geom.Matrix3D;	import flash.geom.Vector3D;	import flash.net.URLRequest;	import flash.utils.Dictionary;		import mx.messaging.AbstractConsumer;		import org.ascollada.core.DaeAnimation;	import org.ascollada.core.DaeBlendWeight;	import org.ascollada.core.DaeChannel;	import org.ascollada.core.DaeController;	import org.ascollada.core.DaeDocument;	import org.ascollada.core.DaeGeometry;	import org.ascollada.core.DaeImage;	import org.ascollada.core.DaeInput;	import org.ascollada.core.DaeInstanceController;	import org.ascollada.core.DaeInstanceGeometry;	import org.ascollada.core.DaeNode;	import org.ascollada.core.DaePrimitive;	import org.ascollada.core.DaeSkin;	import org.ascollada.core.DaeSource;	import org.ascollada.core.DaeTransform;	import org.ascollada.fx.DaeBindVertexInput;	import org.ascollada.fx.DaeColor;	import org.ascollada.fx.DaeEffect;	import org.ascollada.fx.DaeInstanceMaterial;	import org.ascollada.fx.DaeLambert;	import org.ascollada.fx.DaeMaterial;	import org.ascollada.fx.DaePhong;
		use namespace arcane;		/**	 * ColladaParser provides a parser for the Collada (DAE) data type.	 */	public class ColladaParser extends ParserBase	{		private var _uri : String; // temp, I hope		private var _assetNameToAssign : String; // temp, I hope		private var _daeDoc : DaeDocument;		private var _skeleton : Skeleton;		private var _skeletonPose : SkeletonPose;		private var _textureFilenameOverride : String; // TODO, generalize and allow for more than one override				private var _daeParsingState : uint;		private var _bitmapDataAssetMaterialInfo : Object; // daeMaterial.id -> daeLambert		private var _materialIDToSubmesh : Dictionary = new Dictionary(); // daeMaterial.id -> SubMesh		private var _overrideBitmapMaterials : Boolean;		private var _jointsPerVertex : uint = 4; // TODO: should be shared with the value sent to SkeletonAnimation constructor				/**		 * Creates a new ColladaParser object.		 * @param uri The url or id of the data or file to be parsed. TODO: to be removed, and errors sent as events to AssetLoader, where uri is available.		 * @param skeleton Skeleton object if animations are being parsed (REQUIRED if skeleton not in same file as animation)		 * @param textureFilenameOverride a single texture to be loaded instead of referenced texture in file. TODO: fix to allow multiple overrides		 */		public function ColladaParser(uri : String, assetNameToAssign : String = null, skeleton : Skeleton = null, skeletonPose : SkeletonPose = null, textureFilenameOverride : String = null)		{			// TODO, remove uri			// TODO, remove textureFilenameOverride - instead, turn off loading of dependencies and figure out how to associate application provided texture with materialID 			_uri = uri;			if (assetNameToAssign != null)			{				_assetNameToAssign = assetNameToAssign;			}			else			{				_assetNameToAssign = "";			}						if (skeleton)			{				_skeleton = skeleton;			}			else			{				_skeleton = new Skeleton();			}						if (skeletonPose)			{				_skeletonPose = skeletonPose;			}			else			{				_skeletonPose = new SkeletonPose();			}						_textureFilenameOverride = textureFilenameOverride;			_bitmapDataAssetMaterialInfo = new Object();			super(ParserDataFormat.PLAIN_TEXT);		}				/**		 * @inheritDoc		 */		public static function supportsType(extension : String) : Boolean		{			extension = extension.toLowerCase();			return extension == "dae";		}				/**		 * @inheritDoc		 */		override arcane function resolveDependency(resourceDependency:ResourceDependency):void		{			var daeMaterialID:String = resourceDependency.id;			if (_bitmapDataAssetMaterialInfo.hasOwnProperty(daeMaterialID))			{				var daeLambert:DaeLambert = _bitmapDataAssetMaterialInfo[daeMaterialID];								// there should be one bitmapAsset returned for each resourceDependency.				// we'll get separate callbacks for each materialID.				var bitmapDataAsset:BitmapDataAsset = resourceDependency.assets[0] as BitmapDataAsset;				if (bitmapDataAsset != null && (bitmapDataAsset.bitmapData != null) && isBitmapDataValid(bitmapDataAsset.bitmapData))				{					trace("-- [", filenameFromPath(),"] Loaded bitmap for", daeMaterialID);						createAndAssignBitmapMaterial(daeMaterialID, bitmapDataAsset.bitmapData, daeLambert);				}				else				{					createAndAssignColorMaterial(daeMaterialID, 0xFF0000, daeLambert);				}								delete _bitmapDataAssetMaterialInfo[daeMaterialID];			}		}				/**		 * @inheritDoc		 */		override arcane function resolveDependencyFailure(resourceDependency:ResourceDependency):void		{			// apply system default			var daeMaterialID:String = resourceDependency.id;			if (_bitmapDataAssetMaterialInfo.hasOwnProperty(daeMaterialID))			{				var daeLambert:DaeLambert = _bitmapDataAssetMaterialInfo[daeMaterialID];								createAndAssignColorMaterial(daeMaterialID, 0xFF0000, daeLambert);								delete _bitmapDataAssetMaterialInfo[daeMaterialID];			}		}				/**		 * Tests whether a data block can be parsed by the parser.		 * @param data The data block to potentially be parsed.		 * @return Whether or not the given data is supported.		 */		public static function supportsData(data : *) : Boolean		{			// todo: implement			return false;		}				private function filenameFromPath():String		{			var lastSlashIndex:int = this._uri.lastIndexOf("/");			if (lastSlashIndex == -1)			{				return this._uri;			}			else			{				return this._uri.slice(lastSlashIndex+1);			}		}				/**		 * @inheritDoc		 */		protected override function proceedParsing() : Boolean		{			// _daeParsingState key			// 0:just starting			// 1:parsing dae			// 2:done parsing dae			// 3:completely done			// ... : materials assigned one dependencies loaded.						if (_daeParsingState == 0)			{				// set this to true to override every specified texture with red material instead				_overrideBitmapMaterials = false;								trace("-- [", filenameFromPath(),"] [1] collada parse requested");				_daeDoc = new DaeDocument();				var xml:XML = new XML(_textData);				_daeDoc.addEventListener(Event.COMPLETE, onParseColladaDocComplete);				_daeDoc.read(xml);								_daeParsingState++; // to 1								return MORE_TO_PARSE;			}			else if (_daeParsingState == 1)			{				// collada parse in process				return MORE_TO_PARSE;			}			else if (_daeParsingState == 2)			{				continueColladaInterpret(_daeDoc);				return MORE_TO_PARSE;			}			else			{				trace("-- [", filenameFromPath(),"] [3] parsing done!");				return PARSING_DONE;			}		}				private function notifyGoingToStage3():void		{			trace("-- [", filenameFromPath(),"] [3] image loads completed (if any).");		}				// The doc has been read in. Now it must be processed.		private function onParseColladaDocComplete(e:Event):void		{			trace("-- [", filenameFromPath(),"] [2] collada parse completed.");			_daeParsingState++; // to 2		}				private function registerBitmapMaterialWaitingForBitmapData(daeMaterialID:String, daeLambert:DaeLambert):void		{			// many materials may request the same bitmap. this allows them to be loaded			if (!_bitmapDataAssetMaterialInfo.hasOwnProperty(daeMaterialID))			{				_bitmapDataAssetMaterialInfo[daeMaterialID] = daeLambert;			}			else			{				trace("-- [", filenameFromPath(),"] material id", daeMaterialID, "already requested?!?!?!?!");			}		}				private function createAndAssignColorMaterial(daeMaterialID:String, color:uint, daeLambert:DaeLambert):void		{			if (_materialIDToSubmesh.hasOwnProperty(daeMaterialID))			{				var subMesh:SubMesh = _materialIDToSubmesh[daeMaterialID];				var material:ColorMaterial = new ColorMaterial(color);				material.name = daeMaterialID;				material.gloss = 20;				material.specular = 1.5;				material.ambientColor = 0x505060;				applyMaterialParams(material, daeLambert);				subMesh.material = material;				finalizeAsset(material);			}		}				private function createAndAssignBitmapMaterial(daeMaterialID:String, bitmapData:BitmapData, daeLambert:DaeLambert):void		{			if (_materialIDToSubmesh.hasOwnProperty(daeMaterialID))			{				var subMesh:SubMesh = _materialIDToSubmesh[daeMaterialID];				var material:BitmapMaterial = new BitmapMaterial(bitmapData);				material.name = daeMaterialID;				applyMaterialParams(material, daeLambert);				subMesh.material = material;				finalizeAsset(material);			}		}				private function createAndAssignWireframeMaterial(daeMaterialID:String, color:uint, daeLambert:DaeLambert):void		{			if (_materialIDToSubmesh.hasOwnProperty(daeMaterialID))			{				var subMesh:SubMesh = _materialIDToSubmesh[daeMaterialID];				var material:SegmentMaterial = new SegmentMaterial(); // TODO: figure out how to apply lambert.diffuse.color to the wireframe material				material.name = daeMaterialID;				subMesh.material = material;				finalizeAsset(material);			}		}		private function continueColladaInterpret(daeDocument:DaeDocument):void		{			var daeNode:DaeNode;			var traceSerializer:TraceSerializer = new TraceSerializer();			var jointIndex:int;			var jointName:String;						// iterate through DaeNode's			if (daeDocument.scene != null)			{				// read skeleton *first*				for each (daeNode in daeDocument.scene.nodes)				{					if (daeNode.type == "JOINT")					{						skeletonFromNode(_skeleton, _skeletonPose, daeNode, -1 /* parentIndex to start */);						_skeletonPose.name = "bind";						finalizeAsset(_skeletonPose);						_skeleton.name = daeDocument.scene.id;						finalizeAsset(_skeleton); // not truly final here - inverseBindPose in each SkeletonJoint hasn't been set					}				}				// ... then read meshes				for each (daeNode in daeDocument.scene.nodes)				{					if (daeNode.type != "JOINT")					{						meshFromNode(null /* parent */, daeNode, new Matrix3D());					}          				}			}						// iterate through DaeAnimation's			if (daeDocument.animations != null)			{				var skeletonPoses:Dictionary;				for each (var daeAnimation:DaeAnimation in daeDocument.animations)				{					if (skeletonPoses == null)					{						skeletonPoses = new Dictionary();					}					skeletonPosesFromAnimation(skeletonPoses, daeAnimation);				}				if (skeletonPoses != null)				{					var jointPoses:Dictionary;					var jointsAnimated:Vector.<String> = new Vector.<String>();					for each (jointPoses in skeletonPoses)					{						for (jointName in jointPoses)						{							if (jointsAnimated.indexOf(jointName) == -1)							{								jointsAnimated.push(jointName);							}						}					}										// where possible, fill in missing jointPoses from daeNode transforms or _skeletonPose					for each (var skeletonJoint:SkeletonJoint in _skeleton.joints)					{						jointName = skeletonJoint.name;						// did any animation address this joint in the skeleton?						if (jointsAnimated.indexOf(jointName) == -1)						{							var bindJointPose:JointPose;							daeNode = daeDocument.getNodeByID(jointName);							if (daeNode)							{								// if daeNode exists for this joint (e.g. collada has joint)								// use daeTransforms to create proper jointPose								var poseTransform:Matrix3D = new Matrix3D();								for each (var daeTransform:DaeTransform in daeNode.transforms)								{									prependTransformToMatrix(poseTransform, daeTransform);								}																bindJointPose = new JointPose();								bindJointPose.name = jointName;								bindJointPose.translation = poseTransform.position;								var orientation:Quaternion = new Quaternion();								orientation.fromMatrix(poseTransform);								bindJointPose.orientation = orientation;							}							else							{								// collada must not have required joint.  used passed in _skeletonPose to fill in the blanks in the joint pose								bindJointPose = _skeletonPose.jointPoseFromName(jointName);							}														// walk through every skeletonPose in the dictionary we just created, and copy over the bindJointPose							for each (jointPoses in skeletonPoses)							{								jointPose = new JointPose();								jointPose.name = jointName;								jointPose.copyFrom(bindJointPose);								jointPoses[jointName] = jointPose;							}						}					}										// sort poses based on keyFrameTime (the key in the skeletonPoses Dictionary)					var keyFrameTimes:Vector.<String> = new Vector.<String>;					var keyFrameTime:String;					for (keyFrameTime in skeletonPoses)					{						keyFrameTimes.push(keyFrameTime);					}										// temp use URI to identify animation sequence					var skeletonAnimationSequence:SkeletonAnimationSequence = new SkeletonAnimationSequence("anim"); 					var sortedKeyFrameTimes:Vector.<String> = keyFrameTimes.sort(sortStringsAsNumbers);					var durationMilliseconds:uint = (Number(sortedKeyFrameTimes[1])- Number(sortedKeyFrameTimes[0])) * 1000;					for each (keyFrameTime in sortedKeyFrameTimes)					{						var skeletonPose:SkeletonPose = createSkeletonPose();						jointPoses = skeletonPoses[keyFrameTime];						for (jointName in jointPoses)						{							// find out which jointIndex this skeleton has for this jointName							jointIndex = _skeleton.jointIndexFromName(jointName);							if (jointIndex != -1)							{								var jointPose:JointPose = jointPoses[jointName];								skeletonPose.jointPoses[jointIndex] = jointPose;							}							else							{								var parseErrorEvent:ParserEvent = new ParserEvent(ParserEvent.PARSE_ERROR);								dispatchEvent(parseErrorEvent);								// TODO, send more specific information in parseErrorEvent.								trace("-- [", filenameFromPath(),"] ERROR: joint", jointName, "not in provided skeleton!");							}						}												skeletonAnimationSequence.addFrame(skeletonPose, durationMilliseconds);					}										finalizeAsset(skeletonAnimationSequence);				}			}			_daeParsingState++; // to 3		}				// requires _skeleton be set up		private function createSkeletonPose():SkeletonPose		{			var skeletonPose:SkeletonPose = new SkeletonPose();			for each (var skeletonJoint:SkeletonJoint in _skeleton.joints)			{				var jointPose:JointPose = new JointPose();				jointPose.name = skeletonJoint.name;				skeletonPose.jointPoses.push(jointPose);			}			return skeletonPose;		}				private function sortStringsAsNumbers(a:String, b:String):Number		{			if (Number(a) < Number(b))			{				return -1;			}			else if (Number(a) > Number(b))			{				return 1;			}			else			{				return 0;			}		}				private function applyMaterialParams(material:DefaultMaterialBase, daeLambert:DaeLambert):void		{			//daeLambert.emission			//daeLambert.transparent			//daeLambert.transparency						if (daeLambert.ambient.color)			{				material.ambientColor = buildColor(daeLambert.ambient.color);			}						if (daeLambert.diffuse.color)			{				material.diffuseMethod.diffuseColor = buildColor(daeLambert.diffuse.color);			}						if (daeLambert is DaePhong)			{				var daePhong:DaePhong = daeLambert as DaePhong;								if (daePhong.specular.color)				{					material.specularColor = buildColor(daePhong.specular.color);				}								//daePhong.shininess				//daePhong.reflective				//daePhong.reflectivity			}		}				private function prependTransformToMatrix(matrix:Matrix3D, daeTransform:DaeTransform):void		{			// note: prepend* operations here operate on RHS			// e.g. matrix = matrix * rhs			var v:Vector.<Number> = daeTransform.data;			switch (daeTransform.nodeName)			{				case "rotate":					matrix.prependRotation(v[3], new Vector3D(v[0], v[1], v[2]));					break;				case "scale":					matrix.prependScale(v[0], v[1], v[2]);					break;				case "translate":					matrix.prependTranslation(v[0], v[1], v[2]);					break;				case "matrix":					var colladaMatrix:Matrix3D = new Matrix3D();					colladaMatrix.rawData = v; // collada has row-major data, we want column major					colladaMatrix.transpose();					matrix.prepend(colladaMatrix);					break;				// missing at least				// "lookat"				// "skew"				default:					throw new Error("Unknown transform type: " + daeTransform.nodeName);			}		}				private function prependTransformWithOffsetToMatrix(matrix:Matrix3D, daeTransform:DaeTransform, offset:Vector.<Number>):void		{			// note: prepend* operations here operate on RHS			// e.g. matrix = matrix * rhs			var v:Vector.<Number> = daeTransform.data;			switch (daeTransform.nodeName)			{				case "rotate":					matrix.prependRotation(v[3] + offset[0], new Vector3D(v[0], v[1], v[2]));					break;				case "scale":					throw new Error("unimplemented!");					// TODO: figure out how to use collada target addressing to figure out if scalex/y/z being modified 					matrix.prependScale(v[0], v[1], v[2]);					break;				case "translate":					throw new Error("unimplemented!");					// TODO: figure out how to use collada target addressing to figure out if transx/y/z being modified 					matrix.prependTranslation(v[0], v[1], v[2]);					break;				case "matrix":					throw new Error("unimplemented!");					// TODO: figure out how to use collada target addressing to figure out which elements of matrix being modified 					var colladaMatrix:Matrix3D = new Matrix3D();					colladaMatrix.rawData = v; // collada has row-major data, we want column major					colladaMatrix.transpose();					matrix.prepend(colladaMatrix);					break;				case "lookat":				case "skew":					throw new Error("unimplemented!");				default:					throw new Error("Unknown transform type: " + daeTransform.nodeName);			}		}				private function matrixFromNode(daeNode:DaeNode):Matrix3D		{			var matrix:Matrix3D = new Matrix3D();						// setup the initial transform - there may be several that collada stacks together here.			for each (var daeTransform:DaeTransform in daeNode.transforms)			{				prependTransformToMatrix(matrix, daeTransform);			}						return matrix;		}				// this adjusts the given transform from right-handed X,Y,Z UP to left-handed Y-UP		private function adjustTransformBasedOnUpAxis(transform:Matrix3D, up_axis:String):void		{			switch (up_axis)			{				case "X_UP":					transform.prependRotation(90, Vector3D.Z_AXIS);					transform.prependScale(1,-1,1);					break;				case "Y_UP":					transform.prependScale(-1,1,1);					break;				case "Z_UP":					//accumulatedTransform.appendScale(-1,1,1);					transform.appendRotation(90, Vector3D.X_AXIS);					break;			}		}				private function skeletonFromNode(skeleton:Skeleton, skeletonPose:SkeletonPose, daeNode:DaeNode, parentJointIndex:int):void		{			var thisSkeletonJoint:SkeletonJoint = new SkeletonJoint();			thisSkeletonJoint.parentIndex = parentJointIndex;			thisSkeletonJoint.name = daeNode.name;			var inverseBindPose:Matrix3D = new Matrix3D();			thisSkeletonJoint.inverseBindPose = inverseBindPose.rawData;			// do not fill in thisSkeletonJoint.inverseBindPose for real here - filled in elsewhere			var jointIndex:int = skeleton.joints.push(thisSkeletonJoint) - 1;						var jointPose:JointPose = new JointPose();			jointPose.name = daeNode.name;			var nodeMatrix:Matrix3D = matrixFromNode(daeNode);      //if (parentJointIndex == -1)      //{//        adjustTransformBasedOnUpAxis(nodeMatrix, daeNode.document.up_axis);              //}			jointPose.orientation.fromMatrix(nodeMatrix);			jointPose.translation = nodeMatrix.position;			skeletonPose.jointPoses.push(jointPose);						// recurse node children			for each (var daeChildNode:DaeNode in daeNode.nodes)			{				skeletonFromNode(skeleton, skeletonPose, daeChildNode, jointIndex);			}		}				private function skeletonPosesFromAnimation(skeletonPoses:Dictionary, daeAnimation:DaeAnimation):void		{			for each (var daeChannel:DaeChannel in daeAnimation.channels)			{				var jointName:String = daeChannel.targetID;				var transformComponentName:String = daeChannel.targetSID;								var daeNode:DaeNode = daeChannel.document.getNodeByID(jointName);								var inputDaeSource:DaeSource = daeChannel.sampler.input; // keyframe time values				var outputDaeSource:DaeSource = daeChannel.sampler.output; // pose matrices								trace(daeChannel.toString());								// TODO!				//var interpolationsDaeSource:DaeSource = daeChannel.sampler.interpolations; // interpolation type for animation between poses								// TODO: properly handle/bake together multiple daeChannel - at this point, our data only contains one daeChannel per anim/joint				var inputIndex:uint;				for each (var input:Number in inputDaeSource.dataFloat)				{					// retrieve or create Vector.<JointPose> for this input (time)					// we do this instead of SkeletonPose (at this time) because 					// there may be more than one daeChannel affecting the same joints.					var inputString:String = String(input);					var jointPoses:Dictionary;					if (skeletonPoses.hasOwnProperty(inputString))					{						jointPoses = skeletonPoses[inputString];					}					else					{						//jointPoses = new Vector.<JointPose>();						jointPoses = new Dictionary();						skeletonPoses[inputString] = jointPoses;					}										var jointPose:JointPose = new JointPose();					jointPose.name = jointName;										var poseTransform:Matrix3D = new Matrix3D();										if (daeNode)					{						for each (var daeTransform:DaeTransform in daeNode.transforms)						{							if (daeTransform.sid == transformComponentName)							{								prependTransformWithOffsetToMatrix(poseTransform, daeTransform, outputDaeSource.dataFloat[inputIndex]);							}							else							{								prependTransformToMatrix(poseTransform, daeTransform);							}						}					}					else					{						// without DaeNode, assume that the pose is absolute (that the animation data was not in the same file as the skeleton nodes)						poseTransform.rawData = outputDaeSource.dataFloat[inputIndex]; // collada has row-major data, we want column major						poseTransform.transpose();					}										jointPose.translation = poseTransform.position;					var orientation:Quaternion = new Quaternion();					orientation.fromMatrix(poseTransform);					jointPose.orientation = orientation;										if (jointPoses.hasOwnProperty(jointPose.name))					{						var parseErrorEvent:ParserEvent = new ParserEvent(ParserEvent.PARSE_ERROR);						dispatchEvent(parseErrorEvent);						// TODO, send more specific information in parseErrorEvent.						trace("-- [", filenameFromPath(),"] ERROR: joint", jointPose.name, "already exists in pose!");					}					jointPoses[jointPose.name] = jointPose;					inputIndex++;				}			}		}				private function meshFromNode(parent:Mesh, daeNode:DaeNode, accumulatedTransform:Matrix3D, addToParentMesh:Boolean = false):void		{			var daeGeometry:DaeGeometry;			var daeInstanceMaterial:DaeInstanceMaterial;			var daePrimitive:DaePrimitive;			var daeBindVertexInput:DaeBindVertexInput;			var uvInputSet:int;			var instance:Mesh;			if (addToParentMesh)			{				// reuse existing mesh - do not add geometry from this node to a separate mesh.				instance = parent;								accumulatedTransform.prepend(matrixFromNode(daeNode));			}			else			{				instance = new Mesh();							if (parent != null)				{					parent.addChild(instance);				}								instance.transform = matrixFromNode(daeNode);				accumulatedTransform.prepend(instance.transform);				//adjustTransformBasedOnUpAxis(accumulatedTransform, daeNode.document.up_axis);				instance.name = daeNode.name;			}						// We make an assumption here - if there is a DaeInstanceController, then there will NOT be a DaeInstanceGeometry.			// Spec isn't clear whether there can be both in a single node.						// We also assume that all nodes in the tree are either ALL skins or not. (addToParentMesh changed to true below)			var childAddToParentMesh:Boolean;			if (daeNode.controllerInstances.length)			{				for each (var daeInstanceController:DaeInstanceController in daeNode.controllerInstances)				{					var daeController:DaeController = daeNode.document.controllers[daeInstanceController.url];										// controllers, can be of type 'skin' or 'morph'					if (daeController.skin)					{						childAddToParentMesh = true;						daeGeometry = daeNode.document.geometries[daeController.skin.source];						for each (daeInstanceMaterial in daeInstanceController.bindMaterial.instanceMaterials)						{							for each (daePrimitive in daeGeometry.mesh.primitives)							{								// pick out the right daePrimitive for this daeInstanceMaterial								if (daeInstanceMaterial.symbol == daePrimitive.material)								{									var skinnedSubGeometry:SkinnedSubGeometry = new SkinnedSubGeometry(_jointsPerVertex);									instance.geometry.addSubGeometry(skinnedSubGeometry);																		// DaeInstanceMaterial.target corresponds to DaeMaterial.name									cacheMaterialReference(instance, skinnedSubGeometry as SubGeometry, daeInstanceMaterial.target);									// figure out accumulated Bind Shape Matrix for this skin									// note that this matrix is NOT related to any particular joint.  you need to look at the defaultSkeletonPose for that.									var accumulatedBindShapeMatrix:Matrix3D = accumulatedTransform.clone();									var colladaMatrix:Matrix3D = new Matrix3D();									colladaMatrix.rawData = daeController.skin.bind_shape_matrix.data; // collada has row-major data, we want column major									colladaMatrix.transpose();									accumulatedBindShapeMatrix.prepend(colladaMatrix);																		uvInputSet = applyMaterial(skinnedSubGeometry, daeInstanceMaterial);									applyGeometry(skinnedSubGeometry, daePrimitive, daeController.skin, accumulatedBindShapeMatrix, uvInputSet, instance);																		// we found the daePrimitive that corresponds to this daeInstanceMaterial. stop looking.									break;								}							}						}					}					else if (daeController.morph)					{						throw new Error("morph!");					}					else					{						throw new Error("A COLLADA controller should be of type <skin> or <morph>!");					}				}			}			else if (daeNode.geometryInstances.length)			{				for each (var daeInstanceGeometry:DaeInstanceGeometry in daeNode.geometryInstances)				{					daeGeometry = daeNode.document.geometries[daeInstanceGeometry.url];					for each (daeInstanceMaterial in daeInstanceGeometry.bindMaterial.instanceMaterials)					{						for each (daePrimitive in daeGeometry.mesh.primitives)						{							// pick out the right daePrimitive for this daeInstanceMaterial							if (daeInstanceMaterial.symbol == daePrimitive.material)							{								var subGeometry:SubGeometry = new SubGeometry();								instance.geometry.addSubGeometry(subGeometry);																// DaeInstanceMaterial.target corresponds to DaeMaterial.name								cacheMaterialReference(instance, subGeometry, daeInstanceMaterial.target);																uvInputSet = applyMaterial(skinnedSubGeometry, daeInstanceMaterial);								applyGeometry(subGeometry, daePrimitive, null, null, uvInputSet, instance);																// we found the daePrimitive that corresponds to this daeInstanceMaterial. stop looking.								break;							}						}					}				}			}						// recurse node children			for each (var daeChildNode:DaeNode in daeNode.nodes)			{				meshFromNode(instance /* parent */, daeChildNode, accumulatedTransform, childAddToParentMesh);			}						if (!addToParentMesh) 			{				finalizeAsset(instance);			}		}				private function cacheMaterialReference(instance:Mesh, subGeometry:SubGeometry, daeMaterialID:String):void		{			// find which SubMesh has this SubGeometry			// TODO: there should be a more convenient way to discover the SubMesh for a given SubGeometry			var subMesh:SubMesh;			for each (subMesh in instance.subMeshes)			{				if (subMesh.subGeometry == subGeometry)				{					break;				}			}						// assign proper material to this subMesh			_materialIDToSubmesh[daeMaterialID] = subMesh;		}					// this will copy mesh data defined in daePrimitive to subGeometry.		// * daePrimitive is the higher level definition of the mesh.		// * daeSkin (possibly null) to indicate joints and weights for vertices		// * accumulatedBindShapeMatrix (possibly null) to indicate amount to transform vertices		// * uvInputSet is index into uvSets (-1 for none)		// * instance is the mesh to which the subGeometry is attached		private function applyGeometry(subGeometry:SubGeometry, daePrimitive:DaePrimitive, daeSkin:DaeSkin, 																	accumulatedBindShapeMatrix:Matrix3D, uvInputSet:int, instance:Mesh):void		{			// ---- DETERMINE DUPES (IF ANY) ----			var vertexIndexes:Vector.<Vector.<uint>> = daePrimitive.triangles;			var normalIndexes:Vector.<Vector.<uint>> = daePrimitive.normals;			var uvIndexes:Vector.<Vector.<uint>>;			if (uvInputSet >= 0)			{				uvIndexes = daePrimitive.getUVSet(uvInputSet);			}						var vertices:Vector.<Vector.<Number>> = daePrimitive.vertices.source.dataFloat;			var normals:Vector.<Vector.<Number>> = daePrimitive.document.sources[daePrimitive.normalInput.source].dataFloat;			var uvs:Vector.<Vector.<Number>>;			if (uvInputSet >= 0)			{				uvs = daePrimitive.document.sources[daePrimitive.getTexCoordInput(uvInputSet).source].dataFloat;			}			else			{				uvs = new Vector.<Vector.<Number>>();				uvs.push(new Vector.<Number>(2));			}						// 3 vertices (indexes, really) per triangle			// hence, numIndexData here will be 3x number of triangles			var numTriangles:uint = daePrimitive.triangles.length;			var numIndexData:uint = numTriangles*3;						// looks for unique combinations of vertIndex, normIndex, uvIndex			// uniques of those 3 items will indicate the minimum number of indexes we need for the subGeometry we're building.			var indexIsDupeOf:Vector.<int> = new Vector.<int>(numIndexData);						var i:uint, j:uint;						for (i = 0; i < numIndexData; i++)			{				// initialize to "not a dupe"				indexIsDupeOf[i] = -1;			}						var weightIndex:uint;			for (i = 0; i < numIndexData; i++)			{				if (indexIsDupeOf[i] == -1)				{					var tnumi : int = i / 3; // tri num					var vnumi : int = i % 3; // vert num (within tri)					var vertexIndexi:uint = vertexIndexes[tnumi][vnumi];					var normalIndexi:uint = normalIndexes[tnumi][vnumi];					var uvIndexi:uint = uvIndexes ? uvIndexes[tnumi][vnumi] : 0;					var vertexi:Vector.<Number> = vertices[vertexIndexi];					var normali:Vector.<Number> = normals[normalIndexi];					var uvi:Vector.<Number> = uvs[uvIndexi];										for (j = i + 1; j < numIndexData; j++)					{						var tnumj : int = j / 3; // tri num						var vnumj : int = j % 3; // vert num (within tri)						var vertexIndexj:uint = vertexIndexes[tnumj][vnumj];						var normalIndexj:uint = normalIndexes[tnumj][vnumj];						var uvIndexj:uint = uvIndexes ? uvIndexes[tnumj][vnumj] : 0;						var vertexj:Vector.<Number> = vertices[vertexIndexj];						var normalj:Vector.<Number> = normals[normalIndexj];						var uvj:Vector.<Number> = uvs[uvIndexj];												if ((vertexi[0] == vertexj[0]) &&								(vertexi[1] == vertexj[1]) &&								(vertexi[2] == vertexj[2]) &&								(normali[0] == normalj[0]) &&								(normali[1] == normalj[1]) &&								(normali[2] == normalj[2]) &&								(uvi[0] == uvj[0]) &&								(uvi[1] == uvj[1]))						{							var foundDiffJointWeights:Boolean = false;														if (daeSkin)							{								var daeBlendWeightsi:Vector.<DaeBlendWeight> = daeSkin.getBlendWeightsForVertexIndex(vertexIndexi);								var daeBlendWeightsj:Vector.<DaeBlendWeight> = daeSkin.getBlendWeightsForVertexIndex(vertexIndexj);																if (daeBlendWeightsi.length == daeBlendWeightsj.length)								{									var sortedDaeBlendWeightsi:Vector.<DaeBlendWeight> = daeBlendWeightsi.sort(sortBlendWeights);									var sortedDaeBlendWeightsj:Vector.<DaeBlendWeight> = daeBlendWeightsj.sort(sortBlendWeights);																		var numBlendWeights:uint = sortedDaeBlendWeightsi.length;									for (weightIndex = 0; weightIndex < numBlendWeights; weightIndex++)									{										if ((sortedDaeBlendWeightsi[weightIndex].joint  != sortedDaeBlendWeightsj[weightIndex].joint) ||												(sortedDaeBlendWeightsi[weightIndex].weight != sortedDaeBlendWeightsj[weightIndex].weight))										{											foundDiffJointWeights = true;											break;										}									}								}								else								{									foundDiffJointWeights = true;								}							}														// dupe vertexes are defined as equal vertex,normal,uv indexes,joints/weights							if (!foundDiffJointWeights)							{								indexIsDupeOf[j] = i;							}						}					}				}			}						var parseErrorEvent:ParserEvent;			var indexData:Vector.<uint> = new Vector.<uint>();			var vertexData:Vector.<Number> = new Vector.<Number>();			var normalData:Vector.<Number> = new Vector.<Number>();			var uvData:Vector.<Number>;						var newVertexIndex : uint = 0;			var normalSource : DaeSource = daePrimitive.document.sources[daePrimitive.normalInput.source];			var uvSource : DaeSource;			if (uvInputSet >= 0)			{				uvIndexes = daePrimitive.getUVSet(uvInputSet);				uvData = new Vector.<Number>();				var uvInput : DaeInput = daePrimitive.getTexCoordInput(uvInputSet);				uvSource = daePrimitive.document.sources[uvInput.source];			}						var jointName : String;			var jointIndexData : Vector.<Number>;			var jointWeightsData : Vector.<Number>;			if (daeSkin)			{				jointIndexData = new Vector.<Number>();				jointWeightsData = new Vector.<Number>();			}						var accumulatedBindShapeMatrixWithoutTranslate:Matrix3D;			if (accumulatedBindShapeMatrix)			{				accumulatedBindShapeMatrixWithoutTranslate = accumulatedBindShapeMatrix.clone();				accumulatedBindShapeMatrixWithoutTranslate.position.setTo(0,0,0);			}						for (i = 0; i < numIndexData; i++)			{				if (indexIsDupeOf[i] == -1)				{					var tnum : int = i / 3; // tri num					var vnum : int = i % 3; // vert num (within tri)										// ---- INDEX DATA ----					indexData.push(newVertexIndex);										// ---- VERTEX DATA ----					// TODO: these transforms (vertex AND normal) might be better done as a group then one at a time.					var oldVertexIndex : uint = vertexIndexes[tnum][vnum];					var vertex:Vector3D = new Vector3D(						daePrimitive.vertices.source.dataFloat[oldVertexIndex][0],						daePrimitive.vertices.source.dataFloat[oldVertexIndex][1],						daePrimitive.vertices.source.dataFloat[oldVertexIndex][2]);					if (accumulatedBindShapeMatrix)					{						vertex = accumulatedBindShapeMatrix.transformVector(vertex);					}					vertexData.push(vertex.x);					vertexData.push(vertex.y);					vertexData.push(vertex.z);										// ---- NORMAL DATA ----					var oldNormalIndex : uint = normalIndexes[tnum][vnum];					var normal:Vector3D = new Vector3D(						normalSource.dataFloat[oldNormalIndex][0],						normalSource.dataFloat[oldNormalIndex][1],						normalSource.dataFloat[oldNormalIndex][2]);					if (accumulatedBindShapeMatrixWithoutTranslate)					{						normal = accumulatedBindShapeMatrixWithoutTranslate.transformVector(normal);					}					normalData.push(normal.x);					normalData.push(normal.y);					normalData.push(normal.z);										// ---- UV DATA (IF ANY) ----					if (uvIndexes)					{						var oldUVIndex : uint = uvIndexes[tnum][vnum];						uvData.push(      uvSource.dataFloat[oldUVIndex][0]);						uvData.push(1.0 - uvSource.dataFloat[oldUVIndex][1]); // must flip the v around.					}										// ---- JOINT WEIGHTS/INDEXES (IF ANY) ----					if (daeSkin)					{						var daeBlendWeight:DaeBlendWeight;						var daeBlendWeights:Vector.<DaeBlendWeight> = daeSkin.getBlendWeightsForVertexIndex(oldVertexIndex);						var vertJointIndex:uint = 0;						var sortedDaeBlendWeights:Vector.<DaeBlendWeight> = daeBlendWeights.sort(sortBlendWeights);												// count number of nonZero weights						var numNonZeroWeights:uint = 0;						for each (daeBlendWeight in sortedDaeBlendWeights)						{							if (daeBlendWeight.weight == 0)							{								break;							}							numNonZeroWeights++;						}												// if we have more nonZero weights than jointsPerVertex, then we'll truncate,						// but scale the remaining values so they still add up to 1.						var weightSum:Number;						if (numNonZeroWeights > _jointsPerVertex)						{							// sum up all the remaining weights - that becomes the scale factor 							weightSum = 0;							for (weightIndex = 0; weightIndex < _jointsPerVertex; weightIndex++)							{								weightSum += sortedDaeBlendWeights[weightIndex].weight;							}						}						else						{							// no scaling necessary!							weightSum = 1; 						}												var indexIntoDatas : uint;						for each (daeBlendWeight in sortedDaeBlendWeights)						{							if (daeBlendWeight.weight != 0)							{								if (vertJointIndex < _jointsPerVertex)								{									jointName = daeBlendWeight.joint;									var jointIndex:int = _skeleton.jointIndexFromName(jointName);									if (jointIndex != -1)									{										indexIntoDatas = (newVertexIndex * _jointsPerVertex) + vertJointIndex;										// jointIndexes need to be multiplied by 3 (amount of matrix registers)										// NOTE: this came from NSSSkinMesh example code										jointIndexData  [indexIntoDatas] = jointIndex * 3;										jointWeightsData[indexIntoDatas] = daeBlendWeight.weight / weightSum;									}									else									{										parseErrorEvent = new ParserEvent(ParserEvent.PARSE_ERROR);										dispatchEvent(parseErrorEvent);										// TODO, send more specific information in parseErrorEvent.										trace("-- [", filenameFromPath(),"] ERROR: joint", jointName, "not defined in skeleton!");									}																		vertJointIndex++;								}								//else								//{							//		trace("-- [", filenameFromPath(),"] WARN: ignoring joint", jointName, "with weight", daeBlendWeight.weight, "on vertex", newVertexIndex);								//}							}							else							{								// once we hit first zero, stop - we'll only hit zero's after that								break;							}						}												// fill in any remaining joint weights with zero (this may not be strictly necessary						for (; vertJointIndex < _jointsPerVertex; vertJointIndex++)						{							indexIntoDatas = (newVertexIndex * _jointsPerVertex) + vertJointIndex;							jointIndexData  [indexIntoDatas] = 0;							jointWeightsData[indexIntoDatas] = 0;						}					}										newVertexIndex++;				}				else				{					// indexIsDupeOf[] holds index into indexData, and is LOWEST duplicate vert (including vert,normal,uv).					// indexData[] holds newVertexIndex					indexData.push(indexData[indexIsDupeOf[i]]);				}			}						if ((vertexData.length != normalData.length) ||					(uvData && ((vertexData.length / 3) != (uvData.length / 2))))			{				parseErrorEvent = new ParserEvent(ParserEvent.PARSE_ERROR);				dispatchEvent(parseErrorEvent);				// TODO, send more specific information in parseErrorEvent.				trace("-- [", filenameFromPath(),"] vertexData, normalData, and uvData should have same relative number of elements");				trace("-- [", filenameFromPath(),"]  vertexData", vertexData.length / 3, "normalData", normalData.length / 3, "uvData", uvData.length / 2);			}						for (i = 0; i < indexData.length; i++)			{				if (indexData[i] > (vertexData.length / 3) - 1)				{					parseErrorEvent = new ParserEvent(ParserEvent.PARSE_ERROR);					dispatchEvent(parseErrorEvent);					// TODO, send more specific information in parseErrorEvent.					trace("-- [", filenameFromPath(),"] index value (", indexData[i], ") bigger than largest of vertex/normal/uv index (", (vertexData.length / 3) - 1, ")"); 				}			}						subGeometry.updateIndexData(indexData); // triangle indices (into vertex, normal, and uv data)			subGeometry.updateVertexData(vertexData);			subGeometry.updateVertexNormalData(normalData);			if (uvData)			{				subGeometry.updateUVData(uvData);			}						if (daeSkin)			{				var skinnedSubGeometry:SkinnedSubGeometry = SkinnedSubGeometry(subGeometry);				skinnedSubGeometry.updateJointIndexData(jointIndexData);        skinnedSubGeometry.updateJointWeightsData(jointWeightsData);			}			// ---- SKELETON INVERSE BIND POSE ASSIGNMENT ----			// (I wish collada didn't define its data this way, but it does)			var localJointIndex:uint = 0; // jointIndex just for this file - might be different if many colladas are merged			for each (var jointNames:Vector.<String> in daeSkin.joints)			{				jointName = jointNames[0];				var skeletonJoint:SkeletonJoint = _skeleton.jointFromName(jointName);				if (skeletonJoint)				{					var inverseBindPose : Matrix3D = new Matrix3D();					prependTransformToMatrix(inverseBindPose, daeSkin.inv_bind_matrix[localJointIndex]);					//traceSerializer.writeTransform("inverseBindPose "+jointName, inverseBindPose.rawData);					skeletonJoint.inverseBindPose = inverseBindPose.rawData;				}				localJointIndex++;			}		}				// returns uvInputSet (-1 for none)		private function applyMaterial(subGeometry:SubGeometry, daeInstanceMaterial:DaeInstanceMaterial):int		{			var daeDocument:DaeDocument = daeInstanceMaterial.document;			var uvInputSet:int = -1;			var daeMaterial:DaeMaterial = daeDocument.materials[daeInstanceMaterial.target];			if (daeMaterial)			{				var daeEffect:DaeEffect = daeDocument.effects[daeMaterial.instance_effect];								if (daeEffect != null)				{					if (daeEffect.shader is DaeLambert)					{						var daeLambert:DaeLambert = daeEffect.shader as DaeLambert;												if (daeLambert.diffuse.texture && daeEffect.surface)						{							if (_overrideBitmapMaterials)							{								createAndAssignColorMaterial(daeMaterial.id, 0xFF0000, daeLambert);							}							else							{								// TODO: input_semantic here probably shouldn't be hardcoded.								var daeBindVertexInput:DaeBindVertexInput = daeInstanceMaterial.findBindVertexInput(daeLambert.diffuse.texture.texcoord, "TEXCOORD");								if (daeBindVertexInput)								{									uvInputSet = daeBindVertexInput.input_set;								}																// figure out which texture to load								var daeImage:DaeImage = daeDocument.images[daeEffect.surface.init_from];								if (daeImage)								{									var imageURI:String;																		// look for texture override									if (_textureFilenameOverride)									{										imageURI = _textureFilenameOverride;									}									else									{										// TODO: the slice is too special-case										var aPath : Array = _uri.split("/");										aPath.pop();										imageURI = aPath.join("/") + "/" + daeImage.init_from; //daeImage.init_from.slice(2, daeImage.init_from.length);									}																		// request bitmap resource that is referenced herein									trace("-- [", filenameFromPath(),"] Requesting bitmap", imageURI);                  addDependency(daeMaterial.id, new URLRequest(imageURI));									registerBitmapMaterialWaitingForBitmapData(daeMaterial.id, daeLambert);								}							}						}						else if (daeLambert.diffuse.color)						{							if (daeEffect.wireframe)							{								createAndAssignWireframeMaterial(daeMaterial.id, buildColor(daeLambert.diffuse.color), daeLambert);							}							else							{								createAndAssignColorMaterial(daeMaterial.id, buildColor(daeLambert.diffuse.color), daeLambert);							}						}					}				}			}						return uvInputSet;		}				private function sortBlendWeights(a:DaeBlendWeight, b:DaeBlendWeight):Number		{			if (a.weight > b.weight)			{				return -1;			}			else if (a.weight < b.weight)			{				return 1;			}			else			{				if (a.joint < b.joint)				{					return -1;				}				else if (a.joint > b.joint)				{					return 1;				}				else				{					return 0;				}			}		}				/**		 * Build a color from RGB values.		 * 		 * @param	rgb		 *  		 * @return		 */		private function buildColor(daeColor:DaeColor):uint		{			var r:uint = daeColor.r * 0xff;			var g:uint = daeColor.g * 0xff;			var b:uint = daeColor.b * 0xff;			return (r<<16|g<<8|b);		}	}}